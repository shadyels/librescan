/**
 * Recommendations.jsx
 * 
 * Page component at route: /recommendations/:scanId
 * 
 * Purpose:
 * Displays personalized book recommendations generated by the LLM based on
 * the user's scanned bookshelf.
 * 
 * Data loading strategy (two-phase):
 * Phase 1 - CHECK: On mount, call GET /api/recommendations/:scanId
 *   - If 200: recommendations exist in DB, display them immediately
 *   - If 404: no recommendations yet, proceed to Phase 2
 * 
 * Phase 2 - GENERATE: Call POST /api/generate-recommendations
 *   - Shows "Generating Recommendations..." animation during the LLM call
 *   - On success: display the new recommendations
 *   - On error: show error state with retry option
 * 
 * Why two phases:
 * - Revisiting the page doesn't re-trigger the LLM (fast reload from DB)
 * - First visit auto-generates without requiring a button click
 * - The loading state is shown only during actual generation, not on revisits
 * 
 * States:
 * - loading: true during initial fetch (Phase 1)
 * - generating: true during LLM generation (Phase 2)
 * - error: set when any API call fails
 * - recommendations: the final data to display
 * 
 * Dependencies:
 * - react-router-dom: useParams (scanId), useNavigate (back button)
 * - SessionContext: deviceId for API auth
 * - RecommendationCard: individual book card component
 * - SkeletonCard: loading placeholder (reused from existing components)
 */

// -----------------------------------------------------------------------------
// IMPORTS
// -----------------------------------------------------------------------------

// useState: manages component state (loading, generating, error, recommendations, retryCount)
// useEffect: triggers data fetching on mount and when dependencies change
import { useState, useEffect } from 'react'

// useParams: extracts :scanId from the URL /recommendations/:scanId
// useNavigate: programmatic navigation (back button, retry)
// NOTE: Link is NOT imported here. All navigation in this component uses
//       navigate() (imperative), not <Link> (declarative). The back button,
//       retry button, and empty state button all use onClick + navigate().
import { useParams, useNavigate } from 'react-router-dom'

// useSession: provides deviceId from IndexedDB-backed session context.
// deviceId is required for the POST request body to verify scan ownership.
import { useSession } from '../contexts/SessionContext'

// RecommendationCard: renders a single recommendation with cover, title,
// author, personalized reason, categories, and description.
import RecommendationCard from '../components/RecommendationCard'

// SkeletonCard: animated loading placeholder. Reused from the Results page
// to maintain visual consistency during the Phase 1 loading check.
import SkeletonCard from '../components/SkeletonCard'

/**
 * Recommendations page component.
 * 
 * @returns {JSX.Element} The rendered page
 */
export default function Recommendations() {
  // ---- Routing hooks ----
  // useParams extracts :scanId from the URL /recommendations/:scanId
  const { scanId } = useParams()
  // useNavigate provides programmatic navigation (for the back button)
  const navigate = useNavigate()

  // ---- Session context ----
  // deviceId is needed for the POST request to verify scan ownership
  const { deviceId, loading: sessionLoading } = useSession()

  // ---- Component state ----
  // loading: true during the initial GET check (Phase 1)
  const [loading, setLoading] = useState(true)
  // generating: true during LLM generation (Phase 2). Separate from loading
  // because the UI shows different messages for "checking" vs "generating"
  const [generating, setGenerating] = useState(false)
  // error: error message string, or null if no error
  const [error, setError] = useState(null)
  // recommendations: the final data object from the API, containing:
  //   - recommendations: array of {title, author, reason, cover_url, ...}
  //   - metadata: {model_used, processing_time_ms, prompt_books_count}
  const [recommendations, setRecommendations] = useState(null)

  // retryCount: incremented by the retry button to force the useEffect to re-run.
  // useEffect dependencies don't include our state values like loading/error,
  // so we need an explicit counter to trigger a re-fetch.
  const [retryCount, setRetryCount] = useState(0)

  // ---- Retry handler ----
  // Called when the user clicks "Try Again" after an error.
  // Resets state and bumps retryCount to re-trigger the useEffect.
  const handleRetry = () => {
    setError(null)
    setLoading(true)
    setRecommendations(null)
    setRetryCount(prev => prev + 1)
  }

  // ---- Main data loading effect ----
  // Runs when: component mounts, deviceId becomes available, or retry is triggered.
  // Two-phase approach:
  //   Phase 1 (GET): Check if recommendations already exist in DB
  //   Phase 2 (POST): If not, generate them via LLM
  useEffect(() => {
    // Don't fetch until the session is initialized.
    // The session loads from IndexedDB which is async.
    if (sessionLoading) return
    if (!deviceId) return

    async function loadRecommendations() {
      try {
        setLoading(true)
        setError(null)

        // ---- Phase 1: Check for existing recommendations ----
        console.log(`[Recommendations] Checking for existing recommendations for scan ${scanId}`)
        const getResponse = await fetch(`/api/recommendations/${scanId}`)

        if (getResponse.ok) {
          // Recommendations already exist in the database.
          // Display them immediately â€” no LLM call needed.
          const getData = await getResponse.json()
          console.log('[Recommendations] Found existing recommendations')
          setRecommendations(getData.recommendations)
          setLoading(false)
          return
        }

        if (getResponse.status !== 404) {
          // Unexpected error (500, etc.) â€” don't proceed to generation
          const errorData = await getResponse.json().catch(() => ({}))
          throw new Error(errorData.error || `Server error: ${getResponse.status}`)
        }

        // ---- Phase 2: Generate new recommendations ----
        // GET returned 404 â€” no recommendations exist yet.
        // Switch from "loading" to "generating" state for different UI messaging.
        console.log('[Recommendations] No existing recommendations, generating...')
        setLoading(false)
        setGenerating(true)

        const postResponse = await fetch('/api/generate-recommendations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            scan_id: scanId,
            device_id: deviceId
          })
        })

        if (!postResponse.ok) {
          const errorData = await postResponse.json().catch(() => ({}))
          throw new Error(errorData.error || `Generation failed: ${postResponse.status}`)
        }

        const postData = await postResponse.json()
        console.log('[Recommendations] Generation complete')
        setRecommendations(postData.recommendations)
        setGenerating(false)

      } catch (err) {
        console.error(`[Recommendations] Error: ${err.message}`)
        setError(err.message)
        setLoading(false)
        setGenerating(false)
      }
    }

    loadRecommendations()
  }, [scanId, deviceId, sessionLoading, retryCount])
  // Dependency array:
  // - scanId: refetch if the URL changes (different scan)
  // - deviceId: needed for POST, may be null until session loads
  // - sessionLoading: re-run when session finishes loading
  // - retryCount: re-run when user clicks "Try Again"

  // ---- Extract the books array and metadata for rendering ----
  // recommendations is the full object { recommendations: [...], metadata: {...} }
  const books = recommendations?.recommendations || []
  const metadata = recommendations?.metadata || {}

  // ============================================================================
  // RENDER
  // ============================================================================

  return (
    <div className="min-h-screen bg-gray-50">
      {/* ---- Header ---- */}
      <div className="bg-purple-600 text-white py-8 px-4">
        <div className="max-w-4xl mx-auto">
          {/* Back button: navigates to the results page for this scan */}
          <button
            onClick={() => navigate(`/results/${scanId}`)}
            className="flex items-center text-purple-200 hover:text-white transition-colors mb-4"
          >
            {/* Left arrow SVG */}
            <svg
              className="w-5 h-5 mr-1"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M15 19l-7-7 7-7"
              />
            </svg>
            Back to Scan Results
          </button>

          <h1 className="text-3xl font-bold">Your Recommendations</h1>
          <p className="text-purple-200 mt-2">
            Personalized picks based on your bookshelf
          </p>
        </div>
      </div>

      {/* ---- Main content area ---- */}
      <div className="max-w-4xl mx-auto px-4 py-8">

        {/* ---- Loading state (Phase 1: checking for existing) ---- */}
        {loading && (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Show 4 skeleton cards while checking.
                We use fewer than the results page (which shows 8)
                because we only expect 5 recommendations. */}
            {Array.from({ length: 4 }).map((_, i) => (
              <SkeletonCard key={i} />
            ))}
          </div>
        )}

        {/* ---- Generating state (Phase 2: LLM is working) ---- */}
        {generating && (
          <div className="flex flex-col items-center justify-center py-16">
            {/* Animated spinner */}
            <div className="relative">
              {/* Outer ring: spinning purple circle */}
              <div className="w-16 h-16 border-4 border-purple-200 rounded-full animate-spin border-t-purple-600"></div>
              {/* Inner book emoji: pulses while the outer ring spins */}
              <div className="absolute inset-0 flex items-center justify-center">
                <span className="text-2xl animate-pulse">ðŸ“š</span>
              </div>
            </div>

            <h2 className="text-xl font-semibold text-gray-800 mt-6">
              Generating Recommendations...
            </h2>
            <p className="text-gray-500 mt-2 text-center max-w-md">
              Our AI is analyzing your bookshelf and finding personalized picks.
              This usually takes 10-30 seconds.
            </p>
          </div>
        )}

        {/* ---- Error state ---- */}
        {error && (
          <div className="flex flex-col items-center justify-center py-16">
            {/* Error icon */}
            <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mb-4">
              <svg className="w-8 h-8 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>

            <h2 className="text-xl font-semibold text-gray-800">
              Something went wrong
            </h2>
            <p className="text-gray-500 mt-2 text-center max-w-md">
              {error}
            </p>

            {/* Action buttons */}
            <div className="flex gap-4 mt-6">
              <button
                onClick={handleRetry}
                className="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
              >
                Try Again
              </button>
              <button
                onClick={() => navigate(`/results/${scanId}`)}
                className="px-6 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
              >
                Back to Results
              </button>
            </div>
          </div>
        )}

        {/* ---- Success state: show recommendations ---- */}
        {!loading && !generating && !error && books.length > 0 && (
          <>
            {/* Metadata bar: shows how many recommendations and the model used */}
            <div className="flex items-center justify-between mb-6">
              <p className="text-gray-500 text-sm">
                {books.length} recommendation{books.length !== 1 ? 's' : ''} based on {metadata.prompt_books_count || 'your'} book{(metadata.prompt_books_count || 0) !== 1 ? 's' : ''}
              </p>
              {metadata.processing_time_ms && (
                <p className="text-gray-400 text-xs">
                  Generated in {(metadata.processing_time_ms / 1000).toFixed(1)}s
                </p>
              )}
            </div>

            {/* Recommendation cards grid.
                Single column on mobile, 2 columns on medium screens.
                We use gap-6 for breathing room between cards. */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {books.map((book, index) => (
                <RecommendationCard
                  key={`${book.title}-${index}`}
                  book={book}
                />
              ))}
            </div>

            {/* Bottom action: back to results */}
            <div className="mt-8 text-center">
              <button
                onClick={() => navigate(`/results/${scanId}`)}
                className="px-6 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
              >
                Back to Scan Results
              </button>
            </div>
          </>
        )}

        {/* ---- Empty state: LLM returned no recommendations ---- */}
        {!loading && !generating && !error && books.length === 0 && recommendations !== null && (
          <div className="flex flex-col items-center justify-center py-16">
            <span className="text-4xl mb-4">ðŸ¤”</span>
            <h2 className="text-xl font-semibold text-gray-800">
              No Recommendations Generated
            </h2>
            <p className="text-gray-500 mt-2 text-center max-w-md">
              The AI wasn't able to generate recommendations from your scan.
              Try scanning a clearer photo with more visible book spines.
            </p>
            <button
              onClick={() => navigate('/')}
              className="mt-6 px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
            >
              Scan Another Bookshelf
            </button>
          </div>
        )}
      </div>
    </div>
  )
}